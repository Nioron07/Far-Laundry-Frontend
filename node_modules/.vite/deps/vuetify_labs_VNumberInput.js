import {
  VDivider
} from "./chunk-MNJMCKT4.js";
import {
  VTextField,
  makeVTextFieldProps
} from "./chunk-KRHM5JTQ.js";
import {
  useForm
} from "./chunk-PDNVSNNB.js";
import "./chunk-C6UGP6G5.js";
import "./chunk-AX7SPFMF.js";
import {
  forwardRefs
} from "./chunk-ET2GVY6V.js";
import {
  VBtn
} from "./chunk-PALM7ZIL.js";
import "./chunk-RZ56I33J.js";
import "./chunk-3WNOF23L.js";
import "./chunk-TFEKNRJN.js";
import "./chunk-ZB3P46DR.js";
import "./chunk-57HTGMWO.js";
import "./chunk-TLQBSABE.js";
import {
  VDefaultsProvider
} from "./chunk-KKHKXLZM.js";
import "./chunk-6JWCUSTE.js";
import "./chunk-4SE7IBG6.js";
import "./chunk-VSY7QUZ2.js";
import "./chunk-SSHAG7NG.js";
import "./chunk-WGCEP3ZU.js";
import "./chunk-I63XIJYK.js";
import "./chunk-3VVNANOE.js";
import "./chunk-HL65E4WC.js";
import "./chunk-LWD5WB7K.js";
import "./chunk-MH2EVF3J.js";
import "./chunk-UAUW2WKT.js";
import {
  useProxiedModel
} from "./chunk-AJDY3JX4.js";
import {
  clamp,
  genericComponent,
  getDecimals,
  omit,
  propsFactory,
  useRender
} from "./chunk-SQO55FLB.js";
import {
  Fragment,
  computed,
  createVNode,
  mergeProps,
  nextTick,
  onMounted,
  ref
} from "./chunk-U3LI7FBV.js";
import "./chunk-V4OQ3NZ2.js";

// node_modules/vuetify/lib/labs/VNumberInput/VNumberInput.mjs
import "C:/Users/matth/Programs/FAR Laundry Tool/frontend/node_modules/vuetify/lib/labs/VNumberInput/VNumberInput.css";
var makeVNumberInputProps = propsFactory({
  controlVariant: {
    type: String,
    default: "default"
  },
  inset: Boolean,
  hideInput: Boolean,
  modelValue: {
    type: Number,
    default: null
  },
  min: {
    type: Number,
    default: Number.MIN_SAFE_INTEGER
  },
  max: {
    type: Number,
    default: Number.MAX_SAFE_INTEGER
  },
  step: {
    type: Number,
    default: 1
  },
  ...omit(makeVTextFieldProps({}), ["appendInnerIcon", "modelValue", "prependInnerIcon"])
}, "VNumberInput");
var VNumberInput = genericComponent()({
  name: "VNumberInput",
  props: {
    ...makeVNumberInputProps()
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const _model = useProxiedModel(props, "modelValue");
    const model = computed({
      get: () => _model.value,
      set(val) {
        if (val === null) {
          _model.value = null;
          return;
        }
        if (!isNaN(+val) && +val <= props.max && +val >= props.min) {
          _model.value = +val;
        }
      }
    });
    const vTextFieldRef = ref();
    const stepDecimals = computed(() => getDecimals(props.step));
    const modelDecimals = computed(() => typeof model.value === "number" ? getDecimals(model.value) : 0);
    const form = useForm();
    const controlsDisabled = computed(() => props.disabled || props.readonly || (form == null ? void 0 : form.isReadonly.value));
    const canIncrease = computed(() => {
      if (controlsDisabled.value) return false;
      return (model.value ?? 0) + props.step <= props.max;
    });
    const canDecrease = computed(() => {
      if (controlsDisabled.value) return false;
      return (model.value ?? 0) - props.step >= props.min;
    });
    const controlVariant = computed(() => {
      return props.hideInput ? "stacked" : props.controlVariant;
    });
    const incrementIcon = computed(() => controlVariant.value === "split" ? "$plus" : "$collapse");
    const decrementIcon = computed(() => controlVariant.value === "split" ? "$minus" : "$expand");
    const controlNodeSize = computed(() => controlVariant.value === "split" ? "default" : "small");
    const controlNodeDefaultHeight = computed(() => controlVariant.value === "stacked" ? "auto" : "100%");
    const incrementSlotProps = computed(() => ({
      click: onClickUp
    }));
    const decrementSlotProps = computed(() => ({
      click: onClickDown
    }));
    onMounted(() => {
      if (!props.readonly && !props.disabled) {
        clampModel();
      }
    });
    function toggleUpDown() {
      let increment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (controlsDisabled.value) return;
      if (model.value == null) {
        model.value = clamp(0, props.min, props.max);
        return;
      }
      const decimals = Math.max(modelDecimals.value, stepDecimals.value);
      if (increment) {
        if (canIncrease.value) model.value = +(model.value + props.step).toFixed(decimals);
      } else {
        if (canDecrease.value) model.value = +(model.value - props.step).toFixed(decimals);
      }
    }
    function onClickUp(e) {
      e.stopPropagation();
      toggleUpDown();
    }
    function onClickDown(e) {
      e.stopPropagation();
      toggleUpDown(false);
    }
    function onBeforeinput(e) {
      var _a, _b, _c;
      if (!e.data) return;
      const existingTxt = (_a = e.target) == null ? void 0 : _a.value;
      const selectionStart = (_b = e.target) == null ? void 0 : _b.selectionStart;
      const selectionEnd = (_c = e.target) == null ? void 0 : _c.selectionEnd;
      const potentialNewInputVal = existingTxt ? existingTxt.slice(0, selectionStart) + e.data + existingTxt.slice(selectionEnd) : e.data;
      if (!/^-?(\d+(\.\d*)?|(\.\d+)|\d*|\.)$/.test(potentialNewInputVal)) {
        e.preventDefault();
      }
    }
    async function onKeydown(e) {
      if (["Enter", "ArrowLeft", "ArrowRight", "Backspace", "Delete", "Tab"].includes(e.key) || e.ctrlKey) return;
      if (["ArrowDown", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
        clampModel();
        await nextTick();
        if (e.key === "ArrowDown") {
          toggleUpDown(false);
        } else {
          toggleUpDown();
        }
      }
    }
    function onControlMousedown(e) {
      e.stopPropagation();
    }
    function clampModel() {
      if (!vTextFieldRef.value) return;
      const inputText = vTextFieldRef.value.value;
      if (inputText && !isNaN(+inputText)) {
        model.value = clamp(+inputText, props.min, props.max);
      } else {
        model.value = null;
      }
    }
    useRender(() => {
      const {
        modelValue: _,
        ...textFieldProps
      } = VTextField.filterProps(props);
      function incrementControlNode() {
        return !slots.increment ? createVNode(VBtn, {
          "disabled": !canIncrease.value,
          "flat": true,
          "key": "increment-btn",
          "height": controlNodeDefaultHeight.value,
          "name": "increment-btn",
          "icon": incrementIcon.value,
          "onClick": onClickUp,
          "onMousedown": onControlMousedown,
          "size": controlNodeSize.value,
          "tabindex": "-1"
        }, null) : createVNode(VDefaultsProvider, {
          "key": "increment-defaults",
          "defaults": {
            VBtn: {
              disabled: !canIncrease.value,
              flat: true,
              height: controlNodeDefaultHeight.value,
              size: controlNodeSize.value,
              icon: incrementIcon.value
            }
          }
        }, {
          default: () => [slots.increment(incrementSlotProps.value)]
        });
      }
      function decrementControlNode() {
        return !slots.decrement ? createVNode(VBtn, {
          "disabled": !canDecrease.value,
          "flat": true,
          "key": "decrement-btn",
          "height": controlNodeDefaultHeight.value,
          "name": "decrement-btn",
          "icon": decrementIcon.value,
          "size": controlNodeSize.value,
          "tabindex": "-1",
          "onClick": onClickDown,
          "onMousedown": onControlMousedown
        }, null) : createVNode(VDefaultsProvider, {
          "key": "decrement-defaults",
          "defaults": {
            VBtn: {
              disabled: !canDecrease.value,
              flat: true,
              height: controlNodeDefaultHeight.value,
              size: controlNodeSize.value,
              icon: decrementIcon.value
            }
          }
        }, {
          default: () => [slots.decrement(decrementSlotProps.value)]
        });
      }
      function controlNode() {
        return createVNode("div", {
          "class": "v-number-input__control"
        }, [decrementControlNode(), createVNode(VDivider, {
          "vertical": controlVariant.value !== "stacked"
        }, null), incrementControlNode()]);
      }
      function dividerNode() {
        return !props.hideInput && !props.inset ? createVNode(VDivider, {
          "vertical": true
        }, null) : void 0;
      }
      const appendInnerControl = controlVariant.value === "split" ? createVNode("div", {
        "class": "v-number-input__control"
      }, [createVNode(VDivider, {
        "vertical": true
      }, null), incrementControlNode()]) : !props.reverse ? createVNode(Fragment, null, [dividerNode(), controlNode()]) : void 0;
      const hasAppendInner = slots["append-inner"] || appendInnerControl;
      const prependInnerControl = controlVariant.value === "split" ? createVNode("div", {
        "class": "v-number-input__control"
      }, [decrementControlNode(), createVNode(VDivider, {
        "vertical": true
      }, null)]) : props.reverse ? createVNode(Fragment, null, [controlNode(), dividerNode()]) : void 0;
      const hasPrependInner = slots["prepend-inner"] || prependInnerControl;
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "onBeforeinput": onBeforeinput,
        "onChange": clampModel,
        "onKeydown": onKeydown,
        "class": ["v-number-input", {
          "v-number-input--default": controlVariant.value === "default",
          "v-number-input--hide-input": props.hideInput,
          "v-number-input--inset": props.inset,
          "v-number-input--reverse": props.reverse,
          "v-number-input--split": controlVariant.value === "split",
          "v-number-input--stacked": controlVariant.value === "stacked"
        }, props.class]
      }, textFieldProps, {
        "style": props.style,
        "inputmode": "decimal"
      }), {
        ...slots,
        "append-inner": hasAppendInner ? function() {
          var _a;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(Fragment, null, [(_a = slots["append-inner"]) == null ? void 0 : _a.call(slots, ...args), appendInnerControl]);
        } : void 0,
        "prepend-inner": hasPrependInner ? function() {
          var _a;
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return createVNode(Fragment, null, [prependInnerControl, (_a = slots["prepend-inner"]) == null ? void 0 : _a.call(slots, ...args)]);
        } : void 0
      });
    });
    return forwardRefs({}, vTextFieldRef);
  }
});
export {
  VNumberInput
};
//# sourceMappingURL=vuetify_labs_VNumberInput.js.map
